
rm(list=ls())

# setwd("/Users/fatihki/UiO/SemiParMixtureCure") # for macbook
setwd("/Users/fatihkizilaslan/FatihK/SemiParMixtureCure") # for new macbook
# setwd("/home/fatihki/SemiParMixtureCure") # for med-biostat2
# in HSMCM.HSMCFM Rstan: r1=1, delta1=1e-04, r2=1, delta2=1e-04,
# In MCMC
# priorPara$r1          <- 1 
# priorPara$delta1      <- 1e-04
# priorPara$r2          <- 1 
# priorPara$delta2      <- 1e-04
Bayes.nonparametric.real.data  <- function(model, data, hyperpar = list(), nchains, nIter, warmup, thin, mcmc.parallel = "foreach",  standardize = FALSE,  probs, save_loglik = 1, seed = NULL  ){
  # x               : number of the data in sim.data
  # sim.data        : list variable, generated data from the parametric baseline model  
  # mcmc.parallel   : parallelization method to be able to run nchains for our MCMC algorithm, can be "lapply" or "foreach" from doParallel package or "parLapply" from parallel package
  
  if (!is.null(seed)) set.seed(seed)
  
  # data                   <- sim.data[[x]]
  # b.true                 <- data$b.true
  # beta.true              <- data$beta.true
  # lambda.true            <- data$baseline.hazard.rates
  n                      <- length(data$observed_time)
  # p1 <- length(beta.true);                p2 <- length(b.true) 
  p1 <- ncol(data$X);                p2 <- ncol(data$Z)
  # settings Rstan
  lambda_a0              <- 0.1;          lambda_b0  <- 0.1 # for lambda prior
  beta_sigma             <- 1000;         b_sigma    <- 1000
  theta_a0               <- 0.1;          theta_b0   <- 0.1 # for Gamma frailty parameter prior for MCFM cases
  survObj                <- list()
  survObj$t              <- data$observed_time
  survObj$di             <- data$delta
  if( standardize == TRUE){  
    survObj$X            <- data$X
    survObj$Z            <- data$Z
  }else{
    survObj$X            <- scale.dummy.matrix(data$X)
    survObj$Z            <- scale.dummy.matrix(data$Z) 
  }
  
  event.time.points		  <- sort( survObj$t[survObj$di == 1] )
  if( probs[1] == 0 ){
    s	                <- c( 0,  2*max(survObj$t) - max( survObj$t[-which(survObj$t==max(survObj$t))] ) )
  }else{
    s	                <- c( 0, as.numeric( quantile(event.time.points, probs = probs ) ),  2*max(survObj$t) - max( survObj$t[-which(survObj$t==max(survObj$t))] ) )
  }
  # s	                    <- c( 0, as.numeric( quantile(event.time.points, probs = c(0.3, 0.6, 0.9)) ),  2*max(survObj$t) - max( survObj$t[-which(survObj$t==max(survObj$t))] ) )
  # v                     <- v.matrix( y=survObj$t, s=s, delta= survObj$di)
  JJ                    <- length(s)-1
  
  priorPara             <- list()
  priorPara$s           <- s 
  priorPara$J           <- JJ
  
  ##### SMCM.Rstan ####
  if(model == "SMCM.Rstan"){
    # SMCM model 
    data.semi.mixture.cure.model <- list(n=n, p1=p1, p2=p2, JJ=JJ,  s=s, t=survObj$t, delta=survObj$di, X=survObj$X, Z=survObj$Z,
                                         lambda_a0 = lambda_a0, lambda_b0=lambda_b0, beta_sigma=beta_sigma, b_sigma=b_sigma, save_loglik = save_loglik  )
    
    SMCM.model          <- stan_model( file = "SMCM.stan" )
    fit                 <- sampling( SMCM.model, data= data.semi.mixture.cure.model,
                                     iter = nIter, warmup = warmup, thin = thin, chains = nchains, cores = nchains, refresh =  nIter/2, 
                                     control = list(adapt_delta=0.80, stepsize=0.1, max_treedepth=15) )
    out                 <- summary(fit)$summary
    Rhat                <- out[, "Rhat"] 
    
    
    if ( check.stan.rhat(fit = fit,  rhat_threshold = 1.1) == FALSE ){
      fit               <- sampling( SMCM.model, data= data.semi.mixture.cure.model,
                                     iter = nIter, warmup = warmup, thin = thin, chains = nchains, cores = nchains,  refresh =  nIter/2, 
                                     control = list(adapt_delta=0.75, stepsize=0.1, max_treedepth=15) )
      out               <- summary(fit)$summary
      Rhat              <- out[, "Rhat"] 
    }
    b.mcmc.chains       <- extract(fit)$b #this is combined of all the chains for b after warmup and thin applied!
    beta.mcmc.chains    <- extract(fit)$beta
    lambda.mcmc.chains  <- extract(fit)$lambda
    if(save_loglik == 1){
      loglik.matrix.chains <- extract(fit)$log_lik
      loo.results          <- mcmc.dic.lpml( survObj, priorPara, loglik.matrix.chains, b.hat.mcmc = colMeans(b.mcmc.chains),
                                             beta.hat.mcmc = colMeans(beta.mcmc.chains) , lambda.hat.mcmc = colMeans(lambda.mcmc.chains), stan.model = TRUE, frailty = FALSE )
    } 
    fit.results         <- c( b.hat = colMeans(b.mcmc.chains) , beta.hat = colMeans(beta.mcmc.chains), 
                              lambda.hat = colMeans(lambda.mcmc.chains),  pz.hat = mean( logit( as.matrix(survObj$Z), colMeans(b.mcmc.chains) ) ),
                              time = sum(get_elapsed_time(fit))/60 )
  }
  
  ##### HSMCM.Rstan ####
  if(model == "HSMCM.Rstan"){
    data.semi.hierarchical.mixture.cure.model <- list(n=n, p1=p1, p2=p2, JJ=JJ, s=s, t=survObj$t, delta=survObj$di, X=survObj$X, Z=survObj$Z,
                                                      lambda_a0 = lambda_a0, lambda_b0=lambda_b0, 
                                                      r1=hyperpar$r1, delta1=hyperpar$delta1, r2=hyperpar$r2, delta2=hyperpar$delta2, save_loglik = save_loglik )
    
    HSMCM.model           <- stan_model( file = "HSMCM.stan" )
    fit                   <- sampling( HSMCM.model, data = data.semi.hierarchical.mixture.cure.model,
                                       iter = nIter, warmup = warmup, thin = thin, chains = nchains, cores = nchains, refresh =  nIter/2,
                                       control = list(adapt_delta=0.80, stepsize=0.1, max_treedepth=15) )
    out                   <- summary(fit)$summary
    Rhat                  <- out[, "Rhat"] 
    if ( check.stan.rhat(fit=fit,  rhat_threshold = 1.1) == FALSE ){
      fit                   <- sampling( HSMCM.model, data = data.semi.hierarchical.mixture.cure.model,
                                         iter = nIter, warmup = warmup, thin = thin, chains = nchains, cores = nchains, refresh =  nIter/2,
                                         control = list(adapt_delta=0.75, stepsize=0.1, max_treedepth=15) )
      out                 <- summary(fit)$summary
      Rhat                <- out[, "Rhat"] 
    }

    b.mcmc.chains         <- extract(fit)$b
    beta.mcmc.chains      <- extract(fit)$beta
    lambda.mcmc.chains    <- extract(fit)$lambda
    if(save_loglik == 1){
      loglik.matrix.chains  <- extract(fit)$log_lik
      loo.results           <- mcmc.dic.lpml( survObj, priorPara, loglik.matrix.chains, b.hat.mcmc = colMeans(b.mcmc.chains),
                                              beta.hat.mcmc = colMeans(beta.mcmc.chains) , lambda.hat.mcmc = colMeans(lambda.mcmc.chains), stan.model = TRUE, frailty = FALSE )
    }
    fit.results           <- c( b.hat = colMeans(b.mcmc.chains) , beta.hat = colMeans(beta.mcmc.chains), 
                              lambda.hat =  colMeans(lambda.mcmc.chains),  pz.hat = mean( logit( as.matrix(survObj$Z), colMeans(b.mcmc.chains) ) ),
                              time = sum(get_elapsed_time(fit))/60 )
  }

  # Frailty Models via Rstan
  ##### SMCFM.Rstan ####
  if(model == "SMCFM.Rstan"){
    data.semi.mixture.cure.frailty.model <- list(n=n, p1=p1, p2=p2, JJ=JJ, s=s, t=survObj$t, delta=survObj$di, X=survObj$X, Z=survObj$Z,
                                                 lambda_a0 = lambda_a0, lambda_b0=lambda_b0, beta_sigma=beta_sigma, b_sigma=b_sigma,
                                                 theta_a0 = theta_a0, theta_b0 = theta_b0, save_loglik = save_loglik  ) 
    
    SMCFM.model            <- stan_model( file = "SMCFM.stan" )
    fit                    <- sampling( SMCFM.model, data = data.semi.mixture.cure.frailty.model,
                                        iter = nIter, warmup = warmup, thin = thin, chains = nchains, cores = nchains, refresh =  nIter/2,
                                        control = list(adapt_delta=0.80, stepsize=0.1, max_treedepth=15) )
    out                   <- summary(fit)$summary
    Rhat                  <- out[, "Rhat"] 
    if ( check.stan.rhat(fit=fit,  rhat_threshold = 1.1) == FALSE ){
      fit                 <- sampling( SMCFM.model, data= data.semi.mixture.cure.frailty.model,
                                       iter = nIter, warmup = warmup, thin = thin, chains = nchains, cores = nchains, refresh =  nIter/2,
                                       control = list(adapt_delta=0.75, stepsize=0.1, max_treedepth=15) )
      out                 <- summary(fit)$summary
      Rhat                <- out[, "Rhat"]
    }
    b.mcmc.chains         <- extract(fit)$b
    beta.mcmc.chains      <- extract(fit)$beta
    lambda.mcmc.chains    <- extract(fit)$lambda
    theta.mcmc.chains     <- extract(fit)$theta
    if(save_loglik == 1){
      loglik.matrix.chains <- extract(fit)$log_lik
      loo.results          <- mcmc.dic.lpml( survObj, priorPara, loglik.matrix.chains, b.hat.mcmc = colMeans(b.mcmc.chains),
                                             beta.hat.mcmc = colMeans(beta.mcmc.chains) , lambda.hat.mcmc = colMeans(lambda.mcmc.chains), stan.model = TRUE, frailty = TRUE,
                                             theta.hat.mcmc = mean(theta.mcmc.chains)  )
    }
    fit.results          <- c( b.hat = colMeans(b.mcmc.chains) , beta.hat = colMeans(beta.mcmc.chains), 
                              lambda.hat =  colMeans(lambda.mcmc.chains),  theta.hat = mean(theta.mcmc.chains),
                              pz.hat = mean( logit( as.matrix(survObj$Z), colMeans(b.mcmc.chains) ) ),
                              time = sum(get_elapsed_time(fit))/60 )
  }
  
  ##### HSMCFM.Rstan ####
  if(model == "HSMCFM.Rstan"){
    data.semi.hierarchical.mixture.cure.frailty.model <- list(n=n, p1=p1, p2=p2, JJ=JJ, s=s, t=survObj$t, delta=survObj$di, X=survObj$X, Z=survObj$Z,
                                                              lambda_a0 = lambda_a0, lambda_b0=lambda_b0, 
                                                              r1=hyperpar$r1, delta1=hyperpar$delta1, r2=hyperpar$r2, delta2=hyperpar$delta2,
                                                              theta_a0 = theta_a0, theta_b0 = theta_b0, save_loglik = save_loglik  )
    
    HSMCFM.model           <- stan_model( file = "HSMCFM.stan" )
    fit                    <- sampling( HSMCFM.model, data = data.semi.hierarchical.mixture.cure.frailty.model,
                                        iter = nIter, warmup = warmup, thin = thin, chains = nchains, cores = nchains, refresh =  nIter/2,
                                        control = list(adapt_delta=0.80, stepsize=0.1, max_treedepth=15) )
    out                    <- summary(fit)$summary
    Rhat                   <- out[, "Rhat"] 
    if ( check.stan.rhat(fit=fit,  rhat_threshold = 1.1) == FALSE ){
      fit                  <- sampling( HSMCFM.model, data = data.semi.hierarchical.mixture.cure.frailty.model,
                                        iter = nIter, warmup = warmup, thin = thin, chains = nchains, cores = nchains, refresh =  nIter/2,
                                        control = list(adapt_delta=0.75, stepsize=0.1, max_treedepth=12) )
      out                  <- summary(fit)$summary
      Rhat                 <- out[, "Rhat"] 
    }
    b.mcmc.chains         <- extract(fit)$b
    beta.mcmc.chains      <- extract(fit)$beta
    lambda.mcmc.chains    <- extract(fit)$lambda
    theta.mcmc.chains     <- extract(fit)$theta
    if(save_loglik == 1){
      loglik.matrix.chains <- extract(fit)$log_lik
      loo.results          <- mcmc.dic.lpml( survObj, priorPara, loglik.matrix.chains, b.hat.mcmc = colMeans(b.mcmc.chains),
                                             beta.hat.mcmc = colMeans(beta.mcmc.chains) , lambda.hat.mcmc = colMeans(lambda.mcmc.chains), stan.model = TRUE, frailty = TRUE,
                                             theta.hat.mcmc = mean(theta.mcmc.chains)  )
    }
    fit.results          <- c( b.hat = colMeans(b.mcmc.chains) , beta.hat = colMeans(beta.mcmc.chains), 
                               lambda.hat =  colMeans(lambda.mcmc.chains),  theta.hat = mean(theta.mcmc.chains),
                               pz.hat = mean( logit( as.matrix(survObj$Z), colMeans(b.mcmc.chains) ) ),
                               time = sum(get_elapsed_time(fit))/60 )
  }
  
  #### SMCM.MCM ####
  # our MCMC algorithm for SMCM 
  if(model == "SMCM.MCMC"){
    #settings r1=hyperpar$r1, delta1=hyperpar$delta1, r2=hyperpar$r2, delta2=hyperpar$delta2,
    #adding new parameters to "priorPara", s, JJ are same as in Rstan
    priorPara$r1          <- hyperpar$r1 #1 
    priorPara$delta1      <- hyperpar$delta1 #1e-04
    priorPara$r2          <- hyperpar$r2 #1 
    priorPara$delta2      <- hyperpar$delta2 #1e-04
    priorPara$a           <- lambda_a0 
    priorPara$b           <- lambda_b0 
    
    initial               <- list()
    initial$beta.ini      <- rep(1, ncol(data$X) )   # instead of beta.true 
    initial$b.ini         <- rep(1, ncol(data$Z) )   # instead of b.true  
    initial$sigmaSq       <- runif(1, 0.1, 10) 
    initial$sigmaStarSq   <- runif(1, 0.1, 10) 
    initial$etaSq         <- 1  
    initial$etaStarSq     <- 1  
    initial$tauSq         <- rexp( length(initial$b.ini), rate = initial$etaSq/2) 
    initial$tauStarSq     <- rexp( length(initial$beta.ini), rate = initial$etaStarSq/2) 
    initial$lambda.ini    <- rgamma( priorPara$J, 1, 1)
    
    if( nchains > 1){
      if (!is.null(seed))  seeds <- sample(1:1e6, nchains)  # random seed generated for per chain if we use fixed seed
      # choose MCMC_SMC chain runnig method
      if(mcmc.parallel == "lapply"){
        fun <- function(i) {
          #update initial points for each chain
          if (!is.null(seed)) set.seed(seeds[i])
          initial$beta.ini <- rep(0.5*i, ncol(survObj$X) )
          initial$b.ini    <- rep(0.5*i, ncol(survObj$Z) )
          return( MCMC_SMC(survObj, priorPara, initial,  nIter, save_loglik ) )
        }
        start.mcmc.smc.time   <- Sys.time()
        fit                   <- lapply( 1:nchains, FUN=fun)
        mcmc.smc.time         <- as.numeric(Sys.time() - start.mcmc.smc.time, units = "mins")
      }
      
      if(mcmc.parallel == "foreach"){
        start.mcmc.smc.time   <- Sys.time()
        library(doParallel)
        cl1                   <- makeCluster( nchains )
        registerDoParallel(cl1)
        clusterCall(cl1, function() library(doParallel) )
        clusterCall(cl1, function() source("MCMC_functions.R") )
        clusterCall(cl1, function() source("SMCM_MCMC.R") )
        fit                <- foreach( i=1:nchains) %dopar% {
          if (!is.null(seed)) set.seed(seeds[i])
          initial$beta.ini <- rep(0.5*i, ncol(survObj$X) )
          initial$b.ini    <- rep(0.5*i, ncol(survObj$Z) )
          fit.mcmc         <- MCMC_SMC(survObj, priorPara, initial,  nIter, save_loglik )
          return(fit.mcmc)
        }
        on.exit(stopCluster(cl1))
        mcmc.smc.time     <- as.numeric(Sys.time() - start.mcmc.smc.time, units = "mins")
      }
      
      if(mcmc.parallel == "parLapply"){
        fun <- function(i, survObj, priorPara, initial, nIter, save_loglik){
          # update initial points for each chain
          if (!is.null(seed)) set.seed(seeds[i])
          initial$beta.ini <- rep(0.5*i, ncol(survObj$X) )
          initial$b.ini    <- rep(0.5*i, ncol(survObj$Z) )
          return( MCMC_SMC(survObj, priorPara, initial,  nIter, save_loglik ) )
        }
        start.mcmc.smc.time   <- Sys.time()
        cl1                   <- makeCluster( nchains )
        clusterCall(cl1, function() library(doParallel) )
        clusterCall(cl1, function() library(parallel) )
        clusterCall(cl1, function() source("MCMC_functions.R") )
        clusterCall(cl1, function() source("SMCM_MCMC.R") )
        fit                  <- parallel::parLapply(cl1, 1:nchains, fun, survObj, priorPara, initial, nIter, save_loglik )
        on.exit(stopCluster(cl1))
        mcmc.smc.time        <- as.numeric(Sys.time() - start.mcmc.smc.time, units = "mins")
      }
      
      Rhat                  <- Rhat.mcmc(fit, warmup, thin )  # using coda
      b.mcmc.chains         <- mcmc.burn.thin(fit, warmup, thin, par = "b") # mcmc chains after removed warmup iterations and thinning
      b.hat.mcmc            <- colMeans( matrix( unlist( lapply(b.mcmc.chains, function(x) colMeans(x) ) ),   nrow = nchains, byrow = T) )
      
      beta.mcmc.chains      <- mcmc.burn.thin(fit, warmup, thin, par = "beta")
      if( ncol( as.matrix(beta.mcmc.chains[[1]]) ) == 1){
        beta.hat.mcmc       <- colMeans( matrix( unlist( lapply(beta.mcmc.chains, function(x) mean(x) ) ),   nrow = nchains, byrow = T) )
      }else{
        beta.hat.mcmc       <- colMeans( matrix( unlist( lapply(beta.mcmc.chains, function(x) colMeans(x) ) ),   nrow = nchains, byrow = T) )
      }
      
      lambda.mcmc.chains    <- mcmc.burn.thin(fit, warmup, thin, par = "lambda")
      if( ncol( as.matrix(lambda.mcmc.chains[[1]]) ) == 1){
        lambda.hat.mcmc     <- colMeans( matrix( unlist( lapply(lambda.mcmc.chains, function(x) mean(x) ) ),   nrow = nchains, byrow = T) ) 
      }else{
        lambda.hat.mcmc     <-  colMeans( matrix( unlist( lapply(lambda.mcmc.chains, function(x) colMeans(x) ) ),   nrow = nchains, byrow = T) ) 
      }
      if(save_loglik == 1){
        loglik.matrix.chains  <- mcmc.burn.thin(fit, warmup, thin, par = "loglik")
        loo.results           <- mcmc.dic.lpml( survObj, priorPara, loglik.matrix.chains, b.hat.mcmc, beta.hat.mcmc, lambda.hat.mcmc, stan.model = FALSE, frailty = FALSE )
      }

    }else{
      # nchains = 1 case
      start.mcmc.smc.time   <- Sys.time()
      fit                   <- MCMC_SMC( survObj, priorPara, initial, nIter, save_loglik )
      mcmc.smc.time         <- as.numeric(Sys.time() - start.mcmc.smc.time, units = "mins")
      
      # apply warmup and thin to all mcmc iterations
      b.mcmc.chains         <- fit$b.p[ -c(1:(warmup+1)), ][seq(1, nIter - warmup, by = thin), ] #even if we have only one chain, we use "b.mcmc.chains" to keep the variable name same
      b.hat.mcmc            <- colMeans( b.mcmc.chains ) 
      
      if( ncol( as.matrix(fit$beta.p) ) == 1){
        beta.mcmc.chains    <- fit$beta.p[ -c(1:(warmup+1)) ][seq(1, nIter - warmup, by = thin) ]
        beta.hat.mcmc       <- mean( beta.mcmc.chains ) 
      }else{
        beta.mcmc.chains    <- fit$beta.p[ -c(1:(warmup+1)), ][seq(1, nIter - warmup, by = thin), ]  
        beta.hat.mcmc       <- colMeans( beta.mcmc.chains ) 
      }
      
      if( ncol( as.matrix(fit$lambda.p) ) == 1){
        lambda.mcmc.chains  <- fit$lambda.p[ -c(1:(warmup+1)) ][ seq(1, nIter - warmup, by = thin) ]
        lambda.hat.mcmc     <- mean( lambda.mcmc.chains ) 
      }else{
        lambda.mcmc.chains  <- fit$lambda.p[-c(1:(warmup+1)), ][seq(1, nIter - warmup, by = thin), ] 
        lambda.hat.mcmc     <- colMeans( lambda.mcmc.chains ) 
      }
      if(save_loglik == 1){
        loglik.matrix.chains <- fit$loglik.matrix[ -c(1:(warmup+1)), ][ seq(1, nIter - warmup, by = thin), ] 
        loo.results          <- mcmc.dic.lpml( survObj, priorPara, loglik.matrix.chains, b.hat.mcmc, beta.hat.mcmc, lambda.hat.mcmc, stan.model = FALSE, frailty = FALSE )
      }
      Rhat                   <- NULL 
    }
    
    pz.hat.mcmc              <- logit( as.matrix(survObj$Z), b.hat.mcmc) 
    fit.results              <- c( b.hat = b.hat.mcmc , beta.hat =  beta.hat.mcmc, 
                                  lambda.hat =  lambda.hat.mcmc,  pz.hat = mean(pz.hat.mcmc),
                                  time = mcmc.smc.time )
  }
  
  #### SMCFM.MCMC ####
  # our MCMC algorithm for SMCFM Frailty Model
  if(model == "SMCFM.MCMC"){
    source("SMCFM_MCMC.R")
    priorPara$r1          <- hyperpar$r1 #1 
    priorPara$delta1      <- hyperpar$delta1 #1e-04
    priorPara$r2          <- hyperpar$r2 #1 
    priorPara$delta2      <- hyperpar$delta2 #1e-04
    priorPara$a           <- lambda_a0 
    priorPara$b           <- lambda_b0
    priorPara$c           <- theta_a0 
    priorPara$d           <- theta_b0 
    
    initial               <- list()
    initial$beta.ini      <- rep(1, ncol(data$X) )
    initial$b.ini         <- rep(1, ncol(data$Z) )   
    initial$sigmaSq       <- runif(1, 0.1, 10) 
    initial$sigmaStarSq   <- runif(1, 0.1, 10) 
    initial$etaSq         <- 1  
    initial$etaStarSq     <- 1  
    initial$tauSq         <- rexp( length(initial$b.ini), rate = initial$etaSq/2) 
    initial$tauStarSq     <- rexp( length(initial$beta.ini), rate = initial$etaStarSq/2) 
    initial$lambda.ini    <- rgamma( priorPara$J, 1, 1)
    initial$theta.ini     <- mean(rgamma( 10, 0.1, 0.1)) # rgamma( 1, 1, 1)
    
    if( nchains > 1){
      if (!is.null(seed))  seeds <- sample(1:1e6, nchains)  # random seed generated for per chain if we use fixed seed
      # choose MCMC_SMCFM chain runnig method
      if(mcmc.parallel == "lapply"){
        fun <- function(i) {
          # update initial points for each chain
          if (!is.null(seed)) set.seed(seeds[i])
          initial$beta.ini   <- rep(0.5*i, ncol(survObj$X) )
          initial$b.ini      <- rep(0.5*i, ncol(survObj$Z) )
          return( MCMC_SMCFM(survObj, priorPara, initial, nIter, save_loglik ) )
        }
        start.mcmc.smcfm.time <- Sys.time()
        fit                   <- lapply( 1:nchains, FUN=fun)
        mcmc.smcfm.time       <- as.numeric(Sys.time() - start.mcmc.smcfm.time, units = "mins")
      }
      
      if(mcmc.parallel == "foreach"){
        start.mcmc.smcfm.time   <- Sys.time()
        library(doParallel)
        cl1 <- makeCluster(nchains)
        clusterCall(cl1, function() library(doParallel) )
        clusterCall(cl1, function() source("MCMC_functions.R") )
        clusterCall(cl1, function() source("SMCFM_MCMC.R") )
        registerDoParallel(cl1)
        fit                  <- foreach( i=1:nchains) %dopar% {
          if (!is.null(seed)) set.seed(seeds[i])
          initial$beta.ini   <- rep(0.5*i, ncol(survObj$X) )
          initial$b.ini      <- rep(0.5*i, ncol(survObj$Z) )
          fit.mcmc           <- MCMC_SMCFM(survObj, priorPara, initial,  nIter, save_loglik )
          return(fit.mcmc)
        }
        on.exit(stopCluster(cl1))
        mcmc.smcfm.time        <- as.numeric(Sys.time() - start.mcmc.smcfm.time, units = "mins")
      }
      
      if(mcmc.parallel == "parLapply"){
        fun <- function(i, survObj, priorPara, initial, nIter, save_loglik) {
          # update initial points for each chain
          if (!is.null(seed)) set.seed(seeds[i])
          initial$beta.ini   <- rep(0.5*i, ncol(survObj$X) )
          initial$b.ini      <- rep(0.5*i, ncol(survObj$Z) )
          return( MCMC_SMCFM(survObj, priorPara, initial, nIter, save_loglik ) )
        }
        start.mcmc.smcfm.time <- Sys.time()
        cl1                   <- makeCluster( nchains )
        clusterCall(cl1, function() library(doParallel) )
        clusterCall(cl1, function() library(parallel) )
        clusterCall(cl1, function() source("MCMC_functions.R") )
        clusterCall(cl1, function() source("SMCFM_MCMC.R") )
        fit                   <- parallel::parLapply(cl1, 1:nchains, fun, survObj, priorPara, initial, nIter, save_loglik )
        on.exit(stopCluster(cl1))
        mcmc.smcfm.time       <- as.numeric(Sys.time() - start.mcmc.smcfm.time, units = "mins")
      }
      
      Rhat                   <- Rhat.mcmc(fit, warmup, thin )  # using coda
      b.mcmc.chains          <- mcmc.burn.thin(fit, warmup, thin, par = "b") 
      b.hat.mcmc             <- colMeans( matrix( unlist( lapply(b.mcmc.chains, function(x) colMeans(x) ) ),  nrow = nchains, byrow = T) )
      
      beta.mcmc.chains       <- mcmc.burn.thin(fit, warmup, thin, par = "beta")
      if( ncol( as.matrix(beta.mcmc.chains[[1]]) ) == 1){
        beta.hat.mcmc        <- colMeans( matrix( unlist( lapply(beta.mcmc.chains, function(x) mean(x) ) ),   nrow = nchains, byrow = T) )
      }else{
        beta.hat.mcmc        <- colMeans( matrix( unlist( lapply(beta.mcmc.chains, function(x) colMeans(x) ) ), nrow = nchains, byrow = T) )
      }
      
      lambda.mcmc.chains    <- mcmc.burn.thin(fit, warmup, thin, par = "lambda")
      if( ncol( as.matrix(lambda.mcmc.chains[[1]]) ) == 1){
        lambda.hat.mcmc     <- colMeans( matrix( unlist( lapply(lambda.mcmc.chains, function(x) mean(x) ) ),   nrow = nchains, byrow = T) ) 
      }else{
        lambda.hat.mcmc     <-  colMeans( matrix( unlist( lapply(lambda.mcmc.chains, function(x) colMeans(x) ) ),   nrow = nchains, byrow = T) ) 
      }
      
      theta.mcmc.chains    <- mcmc.burn.thin(fit, warmup, thin, par = "theta")
      theta.hat.mcmc       <- colMeans( matrix( unlist( lapply(theta.mcmc.chains, function(x) mean(x) ) ),   nrow = nchains, byrow = T) ) 
      
      if(save_loglik == 1){
        loglik.matrix.chains <- mcmc.burn.thin(fit, warmup, thin, par = "loglik") 
        loo.results          <- mcmc.dic.lpml( survObj, priorPara, loglik.matrix.chains, b.hat.mcmc, beta.hat.mcmc, lambda.hat.mcmc, stan.model = FALSE, frailty = TRUE,  theta.hat.mcmc = theta.hat.mcmc ) 
      }
      
    }else{
      start.mcmc.smcfm.time <- Sys.time()
      fit                   <- MCMC_SMCFM( survObj, priorPara, initial, nIter, save_loglik )
      mcmc.smcfm.time       <- as.numeric(Sys.time() - start.mcmc.smcfm.time, units = "mins")
      
      # apply warmup and thin to all mcmc iterations
      b.mcmc.chains         <- fit$b.p[ -c(1:(warmup+1)), ][seq(1, nIter - warmup, by = thin), ] #even if we have only one chain, we use "b.mcmc.chains" to keep the variable name same
      b.hat.mcmc            <- colMeans( b.mcmc.chains ) 
      
      if( ncol( as.matrix(fit$beta.p) ) == 1){
        beta.mcmc.chains    <- fit$beta.p[ -c(1:(warmup+1)) ][seq(1, nIter - warmup, by = thin) ]
        beta.hat.mcmc       <- mean( beta.mcmc.chains ) 
      }else{
        beta.mcmc.chains    <- fit$beta.p[ -c(1:(warmup+1)), ][seq(1, nIter - warmup, by = thin), ]  
        beta.hat.mcmc       <- colMeans( beta.mcmc.chains ) 
      }
      
      if( ncol( as.matrix(fit$lambda.p) ) == 1){
        lambda.mcmc.chains  <- fit$lambda.p[ -c(1:(warmup+1)) ][ seq(1, nIter - warmup, by = thin) ]
        lambda.hat.mcmc     <- mean( lambda.mcmc.chains ) 
      }else{
        lambda.mcmc.chains  <- fit$lambda.p[-c(1:(warmup+1)), ][seq(1, nIter - warmup, by = thin), ] 
        lambda.hat.mcmc     <- colMeans( lambda.mcmc.chains ) 
      }
      
      theta.mcmc.chains     <- fit$theta.p[ -c(1:(warmup+1)) ][ seq(1, nIter - warmup, by = thin) ]
      theta.hat.mcmc        <- mean( theta.mcmc.chains )
      
      if(save_loglik == 1){
        loglik.matrix.chains<- fit$loglik.matrix[ -c(1:(warmup+1)), ][ seq(1, nIter - warmup, by = thin), ] 
        loo.results         <- mcmc.dic.lpml( survObj, priorPara, loglik.matrix.chains, b.hat.mcmc, beta.hat.mcmc, lambda.hat.mcmc, stan.model = FALSE, frailty = TRUE,  theta.hat.mcmc = theta.hat.mcmc ) 
      }
      
      Rhat                  <- NULL 
      
    }
    
    pz.hat.mcmc             <- logit( as.matrix(survObj$Z), b.hat.mcmc) 
    fit.results             <- c( b.hat = b.hat.mcmc , beta.hat =  beta.hat.mcmc, 
                                  lambda.hat = lambda.hat.mcmc, theta.hat =  theta.hat.mcmc, 
                                  pz.hat =  mean(pz.hat.mcmc),
                                  time = mcmc.smcfm.time )
    
  }
  
  if( model %in% c("SMCFM.Rstan", "HSMCFM.Rstan", "SMCFM.MCMC") ){
    if(save_loglik == 1){
      out                   <- list( fit = fit, fit.results = fit.results, Rhat = Rhat, data = survObj, priors = priorPara, 
                                     b.mcmc.chains = b.mcmc.chains, beta.mcmc.chains = beta.mcmc.chains, lambda.mcmc.chains = lambda.mcmc.chains, theta.mcmc.chains = theta.mcmc.chains, 
                                     loglik.matrix.chains = loglik.matrix.chains, loo.results = loo.results   )  
    }else{
      out                   <- list( fit = fit, fit.results = fit.results, Rhat = Rhat, data = survObj, priors = priorPara, 
                                     b.mcmc.chains = b.mcmc.chains, beta.mcmc.chains = beta.mcmc.chains, lambda.mcmc.chains = lambda.mcmc.chains, theta.mcmc.chains = theta.mcmc.chains  )  
    } 
  }else{ # if SMCM models
    if(save_loglik == 1){
      out                   <- list( fit = fit, fit.results = fit.results, Rhat = Rhat, data = survObj, priors = priorPara, 
                                       b.mcmc.chains = b.mcmc.chains, beta.mcmc.chains = beta.mcmc.chains, lambda.mcmc.chains = lambda.mcmc.chains, 
                                       loglik.matrix.chains = loglik.matrix.chains, loo.results = loo.results  )  
    }else{
      out                   <- list( fit = fit, fit.results = fit.results, Rhat = Rhat, data = survObj, priors = priorPara, 
                                     b.mcmc.chains = b.mcmc.chains, beta.mcmc.chains = beta.mcmc.chains, lambda.mcmc.chains = lambda.mcmc.chains ) 
    }
  }
  
  return(out)
}


# calculating posterior SD of the estimates over the MCMC chains for real data analysis
SD.posterior <- function(out, stan.model = FALSE, frailty = FALSE){
  # out: a list variable, the real data analysis output from SMCM_MCMC or SMCFM_MCMC or stan_model
  # stan.model: if TRUE, it is from Stan, if FALSE, it is from our MCMC
  # frailty: if TRUE, it is cure frailty model, if FALSE, it is cure model
  
  if(stan.model == FALSE){
    out$b.mcmc.chains           <- do.call(rbind, out$b.mcmc.chains)
    if( is.null(ncol(out$beta.mcmc.chains[[1]])) == FALSE){
      out$beta.mcmc.chains      <- do.call(rbind, out$beta.mcmc.chains)
    }else{
      out$beta.mcmc.chains      <- matrix(unlist(out$beta.mcmc.chains), ncol = 1)
    }
    if( is.null(ncol(out$lambda.mcmc.chains[[1]])) == FALSE ){
      out$lambda.mcmc.chains    <- do.call(rbind, out$lambda.mcmc.chains)
    }else{
      out$lambda.mcmc.chains    <- matrix(unlist(out$lambda.mcmc.chains), ncol = 1)
    }
    if(frailty == TRUE){
      out$theta.mcmc.chains     <- unlist(out$theta.mcmc.chains)
    }
  }

    b.mcmc.chains.sd            <- apply(out$b.mcmc.chains, 2, sd)
    beta.mcmc.chains.sd         <- apply(out$beta.mcmc.chains, 2, sd)
    lambda.mcmc.chains.sd       <- apply(out$lambda.mcmc.chains, 2, sd)
    out.sd                      <- c( SD.b.hat = b.mcmc.chains.sd, SD.beta.hat = beta.mcmc.chains.sd,  SD.lambda.hat = lambda.mcmc.chains.sd )
    
    if(frailty == TRUE){
      theta.mcmc.chains.sd      <- sd(out$theta.mcmc.chains)
      out.sd                    <- c( SD.b.hat = b.mcmc.chains.sd, SD.beta.hat = beta.mcmc.chains.sd, SD.lambda.hat = lambda.mcmc.chains.sd, SD.theta.hat = theta.mcmc.chains.sd )
    }
    
  return(out.sd)
}

# define the function to get the probabilities for the intervals
get_probs <- function(J) {
  probs <- seq(0, 1.0, length.out = J + 1)
  probs <- probs[-c(1, J + 1)]
  return(probs)
}

print.model <- function(out, stan.model = FALSE, frailty = FALSE){
  # out: a list variable, the real data analysis output from SMCM_MCMC or SMCFM_MCMC or stan_model
  # stan.model: if TRUE, it is from Stan, if FALSE, it is from our MCMC
  # frailty: if TRUE, it is cure frailty model, if FALSE, it is cure model
  if (stan.model == FALSE) {
    cat( "\n-", ifelse( frailty == FALSE, "SMCM.MCMC", "SMCFM.MCMC"), "Model Results (J =", sum( grepl("lambda", names(out$fit.results)) ), ")" ,"\n" )
    df           <- array(out$Rhat, c(length(out$Rhat),5) )
    rownames(df) <- colnames(out$Rhat)
    colnames(df) <- c("Estimate(Mean)", "SD", "HPD lower", "HPD upper", "Rhat")
    df[,1]       <- out$fit.results[1:nrow(df)]
    df[,2]       <- SD.posterior(out, stan.model, frailty )[1:nrow(df)]
    hpd.lower.upper <- as.matrix( rbind(HPD.credible.interval(fit.mcmc.chains=out$fit, pars="b.p",      warmup=out$mcmc.info$warmup, thin=out$mcmc.info$thin ),
                                        HPD.credible.interval(fit.mcmc.chains=out$fit, pars="beta.p",   warmup=out$mcmc.info$warmup, thin=out$mcmc.info$thin ),
                                        HPD.credible.interval(fit.mcmc.chains=out$fit, pars="lambda.p", warmup=out$mcmc.info$warmup, thin=out$mcmc.info$thin) ), ncol=2)
    if(frailty == TRUE) {
      df <- rbind(df, c( out$fit.results["theta.hat"], SD.posterior(out, stan.model, frailty )["SD.theta.hat"], NA, NA, NA))
      hpd.lower.upper <- as.matrix( rbind(hpd.lower.upper,
                                          HPD.credible.interval(fit.mcmc.chains=out$fit, pars="theta.p", warmup=out$mcmc.info$warmup, thin=out$mcmc.info$thin) ), ncol=2)
      rownames(df)[nrow(df)] <- "theta"
    }
    rownames(hpd.lower.upper) <- NULL
    colnames(hpd.lower.upper) <- NULL
    df[,3:4]    <-  hpd.lower.upper
    # round(df,4)
  }else{
    cat( "\n-", ifelse( frailty == FALSE, "HSMCM.Rstan", "HSMCFM.Rstan"), "Model Results (J =", sum( grepl("lambda", names(out$fit.results)) ), ")" ,"\n" )
    n_row        <- length(out$fit.results)-2
    df           <- array(out$Rhat[1:n_row], c(n_row,5) )
    rownames(df) <- names(out$Rhat)[1:n_row]
    colnames(df) <- c("Estimate(Mean)","SD","HPD lower","HPD upper", "Rhat")
    df[,1]       <- out$fit.results[1:n_row]
    df[,2]       <- SD.posterior(out, stan.model, frailty )
    hpd.lower.upper <- as.matrix( rbind(HPD.credible.interval.stan.fit(out, pars = "b.p"),
                                        HPD.credible.interval.stan.fit(out, pars = "beta.p"),
                                        HPD.credible.interval.stan.fit(out, pars = "lambda.p")), ncol=2 )
    if(frailty == TRUE) {
      hpd.lower.upper <- as.matrix( rbind(hpd.lower.upper,
                                          HPD.credible.interval.stan.fit(out, pars="theta.p") ), ncol=2)
    }
    rownames(hpd.lower.upper) <- NULL
    colnames(hpd.lower.upper) <- NULL
    df[,3:4]    <-  hpd.lower.upper
  }
  
  # sd, hpd interval for pi(z)
  if (stan.model == FALSE) {
  mcmc_chains_b     <- lapply( out$fit, function(x) { x$b.p[-c(1), ] } ) #removing the initial values!
  processed_chains_b<- lapply(mcmc_chains_b, function(chain) {
    # Apply burn-in and thinning
    thinned_chain           <- chain[(out$mcmc.info$warmup + 1):nrow(chain), ][seq(1, nrow(chain) - out$mcmc.info$warmup, by = out$mcmc.info$thin), ]
    # Create an mcmc object for each thinned chain
    mcmc(thinned_chain)
  })
  mcmc_list_b       <- mcmc.list(processed_chains_b)
  
  pz                <- lapply( mcmc_list_b, function (x) { 
    apply( x, 1, function (y){ mean(logit( scale.dummy.matrix(out$real.data$Z), y ))  } ) 
  } )
  mcmc_list_pz <- mcmc.list(lapply(pz, mcmc))
  
  Rhat_pz           <- matrix( coda::gelman.diag(mcmc_list_pz, autoburnin = F)$psrf[,1] , nrow=1 )
  sd_pz             <- mean(unlist(lapply(mcmc_list_pz, sd) ) )
  hpd.interval_pz   <- as.data.frame(coda::HPDinterval( as.mcmc(unlist(mcmc_list_pz)), prob = 0.95 ) )
  }else{
    pz              <- apply(out$b.mcmc.chains, 1, function (y){ mean(logit( scale.dummy.matrix(out$real.data$Z), y ))  } )
    # pz              <- apply(out$b.mcmc.chains, 1, function (y){ mean(logit( scale.dummy.matrix(out$data$Z), y ))  } )
    sd_pz           <- sd(pz)
    hpd.interval_pz <- as.data.frame(coda::HPDinterval( as.mcmc(pz), prob = 0.95 ) )
    mcmc_pz_chains  <- mcmc.list(
      lapply(1:out$mcmc.info$chains, function(i) {
        start       <- (i - 1) * (length(pz)/out$mcmc.info$chains) + 1
        end         <- i * (length(pz)/out$mcmc.info$chains)
        mcmc(as.matrix(pz)[start:end, ])
      })
    )
    Rhat_pz         <- matrix( coda::gelman.diag(mcmc(mcmc_pz_chains), autoburnin = F)$psrf[,1] , nrow=1 )
  }
  
  df                <- rbind(df, c( out$fit.results["pz.hat"], sd_pz,  hpd.interval_pz$lower,  hpd.interval_pz$upper, Rhat_pz) )
  rownames(df)[nrow(df)] <- "pi(z)"
  print(round(df,4))
  return( invisible(df) )
}




####### data preparation #######

source("MCMC_functions.R")
source("SMCM_MCMC.R") # our MCMC for MCM 
source("SMCFM_MCMC.R") # # our MCMC for Frailty case

library(coda)
library(loo)
library(rstan)
rstan_options(auto_write = TRUE)
stan_model( file = "SMCM.stan" )
stan_model( file = "SMCFM.stan" )
stan_model( file = "HSMCM.stan" )
stan_model( file = "HSMCFM.stan" )


####### E1690 data analysis as Yin and Ibrahim (2005) using the time to relapse time with its censoring indicator, trt, age and sex variables  #######
#### from https://github.com/psioda/bayes-design-hist-cure-rate/blob/master/data/raw_data/mina-readme.txt
# data <- read.table("/Users/fatihki/UiO/SemiParMixtureCure/mina-e1684-e1690.txt", header = TRUE)
data <- read.table("mina-e1684-e1690.txt", header = TRUE)
table(data$study)
colnames(data)
# data.E1684         <- data[data$study == "1684", ]
# data.E1684$nodes   <- as.numeric(data.E1684$nodes)
# data.E1684$breslow <- as.numeric(data.E1684$breslow)
# data.E1684         <- na.omit(data.E1684)
# dim(data.E1684)
# skimr::skim(data.E1684)

data.E1690         <- data[data$study == "1690", ]
data.E1690$nodes   <- as.numeric(data.E1690$nodes)
# data.E1690$nodes   <- as.factor(data.E1690$nodes)
data.E1690$breslow <- as.numeric(data.E1690$breslow) # 10 NA !!!  # if you use this variable, apply na.omit before that!!!
# data.E1690         <- na.omit(data.E1690)
data.E1690$stage   <- as.factor(data.E1690$stage) # "-2" level should be removed before the use!
dim(data.E1690)
# skimr::skim(data.E1690)

# if we use failtime as a survival time, we need remove failtime=0 observations, there are 10 observations are 0!!
data.E1690.RFS <- data.E1690[data.E1690$failtime > 0, ]
dim(data.E1690.RFS)
summary(data.E1690.RFS$failtime)
table(data.E1690.RFS$rfscens)
summary(data.E1690.RFS$age)
table(data.E1690.RFS$sex)

summary(data.E1690.RFS$failtime[data.E1690.RFS$rfscens==1])
summary(data.E1690.RFS$failtime[data.E1690.RFS$rfscens==0])
summary(data.E1690.RFS$failtime[data.E1690.RFS$trt==1])
summary(data.E1690.RFS$failtime[data.E1690.RFS$trt==0])
# table(data.E1690.RFS$nodes)
# 
# data.E1690.RFS.nodes.dummy.matrix = as.matrix(fastDummies::dummy_columns(data.E1690.RFS$nodes, remove_first_dummy = TRUE, remove_selected_columns=TRUE) )#  only n-1 dummies remain
# colnames(data.E1690.RFS.nodes.dummy.matrix) = paste0("nodes_dummy_", 1:ncol(data.E1690.RFS.nodes.dummy.matrix))
# head(data.E1690.RFS.nodes.dummy.matrix)

# data.E1690.RFS.stage.dummy.matrix = as.matrix(fastDummies::dummy_columns(data.E1690.RFS$stage, remove_first_dummy = TRUE, remove_selected_columns=TRUE) )#  only n-1 dummies remain
# colnames(data.E1690.RFS.stage.dummy.matrix) = paste0("stage_dummy_", 1:ncol(data.E1690.RFS.stage.dummy.matrix))
# head(data.E1690.RFS.stage.dummy.matrix)

data.E1690.OS  <- data.E1690[data.E1690$survtime > 0, ]
data.E1690.OS  <- na.omit(data.E1690.OS) # wrt tumor thickness which has 10 NA it removed from the data in Balaksrihnan 2016, others follow this format!
table(data.E1690.OS$scens)
summary(data.E1690.OS$survtime)
sd(data.E1690.OS$survtime)
table(data.E1690.OS$nodes) # after remove 10 NA tumor thickness, nodes are 111, 137, 87, 82 as in the  Castro, Gomez (2020) paper!

# data.E1690.OS.nodes.dummy.matrix = as.matrix(fastDummies::dummy_columns(data.E1690.OS$nodes, remove_first_dummy = TRUE, remove_selected_columns=TRUE) )#  only n-1 dummies remain
# colnames(data.E1690.OS.nodes.dummy.matrix) = paste0("nodes_dummy_", 1:ncol(data.E1690.OS.nodes.dummy.matrix))
# head(data.E1690.OS.nodes.dummy.matrix)
# note this data.E1690.OS is the exact same as the used in the paper "A Bayesian Cure Rate Model Based on the Power Piecewise Exponential Distribution, Castro, Gomez (2020)"
# there they used "survtime" and "scens" as survival time and censoring indicators, respectively also nodule category (nodes)

# library(survival)
# library(survminer)
# library(ggplot2)
# 

# 
# 
# 
fit.E1690.nodes <- survfit(Surv(survtime, scens) ~ nodes, data = data.E1690.OS)
ggsurvplot(fit.E1690.nodes)

# data.E1690.nodes.dummy.matrix = as.matrix(fastDummies::dummy_columns(data.E1690$nodes, remove_first_dummy = TRUE, remove_selected_columns=TRUE) )#  only n-1 dummies remain
# colnames(data.E1690.nodes.dummy.matrix) = paste0("nodes_dummy_", 1:ncol(data.E1690.nodes.dummy.matrix))
# head(data.E1690.nodes.dummy.matrix)
# 
# data.E1690.nodes.binary.matrix = as.matrix(fastDummies::dummy_columns(data.E1690$nodes,remove_selected_columns=TRUE))
# colnames(data.E1690.nodes.binary.matrix) = paste0("nodes_level_", 1:4)
# head(data.E1690.nodes.binary.matrix)
# 
# data.E1690.stage.dummy.matrix = as.matrix(fastDummies::dummy_columns(data.E1690$stage, remove_first_dummy = TRUE, remove_selected_columns=TRUE) )#  only n-1 dummies remain
# colnames(data.E1690.stage.dummy.matrix) = paste0("stage_dummy_", 1:ncol(data.E1690.stage.dummy.matrix))
# head(data.E1690.stage.dummy.matrix)
# 
# data.E1690.stage.binary.matrix = as.matrix(fastDummies::dummy_columns(data.E1690$stage, remove_selected_columns=TRUE) )
# colnames(data.E1690.stage.binary.matrix) = paste0("stage_level_", 1:4)
# head(data.E1690.stage.binary.matrix)

# real data based on the relapse free survival time
real.data.RFS = list()
real.data.RFS$X =  as.matrix( cbind( trt=data.E1690.RFS$trt, age=data.E1690.RFS$age, sex=data.E1690.RFS$sex  ) )
head(real.data.RFS$X)
real.data.RFS$Z =  cbind(1, real.data.RFS$X)
head(real.data.RFS$Z)

real.data.RFS$observed_time = data.E1690.RFS$failtime 
real.data.RFS$delta         = data.E1690.RFS$rfscens 

table(real.data.RFS$delta)
table(data.E1690.RFS$sex)
table(data.E1690.RFS$trt)
summary(data.E1690.RFS$failtime); sd(data.E1690.RFS$failtime)
summary(data.E1690.RFS$age)

library(survival)
library(survminer)

fit.E1690.RFS <- survfit(Surv(failtime, rfscens) ~ 1, data = data.E1690.RFS) 
ggsurvplot(fit.E1690.RFS, conf.int = FALSE, palette = "black") 


real.data1.p1 = ggsurvplot(
  fit.E1690.RFS,
  conf.int = FALSE,
  palette  = "black",
  xlab = "Time (years)",
  ylab = "Relapse-Free Survival Probability",
  legend = "none",
  censor.size = 4,
  xlim = c(0, 7),
  break.x.by = 1
)
real.data1.p1

fit.E1690.RFS.trt <- survfit(Surv(failtime, rfscens) ~ trt, data = data.E1690.RFS)
ggsurvplot(fit.E1690.RFS.trt)

real.data1.p2 = 
ggsurvplot(
  fit.E1690.RFS.trt,
  conf.int = FALSE,
  palette = c("black", "gray"),     # both curves black
  linetype = c("solid", "dotted"),   # one solid, one dashed
  xlab = "Time (years)",
  ylab = "Relapse-Free Survival Probability",
  legend.title = "Treatment",
  legend.labs = c("OBS", "High-dose IFN"),  # labels for trt=0 and trt=1
  censor = T,
  censor.size = 4,
  xlim = c(0, 7),
  break.x.by = 1
)
real.data1.p2

# library(ggpubr)
# ggarrange(real.data1.p1$plot, real.data1.p2$plot, nrow = 1, ncol = 2)
library(patchwork)
combined.real.data1.KM.plot <- real.data1.p1$plot + real.data1.p2$plot
combined.real.data1.KM.plot
  
combined.real.data1.KM.plot + gg.model
# stack with shared y-axis
# combined.real.data1.KM.plot + plot_layout( axes = "collect")
  
# ggsave( "real.data1.KM.plots.pdf", combined.real.data1.KM.plot, width = 14, height = 6)




# real data based on the overall survival time
real.data.OS = list()
# real.data.OS$X = as.matrix( cbind( trt=data.E1690.OS$trt, age=data.E1690.OS$age,
#                                    sex=data.E1690.OS$sex ) )
real.data.OS$X = as.matrix(cbind(nodes = data.E1690.OS$nodes))
# nodes=as.numeric(data.E1690.OS$nodes, ps=data.E1690.OS$perform, tt=data.E1690.OS$breslow
head(real.data.OS$X)
# head(scale.dummy.matrix(real.data.OS$X))
real.data.OS$Z =  cbind(1, real.data.OS$X)  # cbind(1, data.E1690.OS.nodes.dummy.matrix) #
head(real.data.OS$Z)

real.data.OS$observed_time = data.E1690.OS$survtime
real.data.OS$delta         = data.E1690.OS$scens



######## RFS data analysis ##########
#### 1. smcure package ####
library(smcure)
survfit(Surv(failtime, rfscens) ~ trt, data = data.E1690.RFS)

# Surv(data.E1690.RFS$failtime,data.E1690.RFS$rfscens)~data.E1690.RFS$trt + data.E1690.RFS$age + data.E1690.RFS$sex
set.seed(5092025)
smcure.fit.500 = smcure(Surv(failtime,rfscens) ~ trt + age + sex,
                    cureform=~trt+age+sex,data=data.E1690.RFS, model="ph",
                    Var = T, nboot = 500)
printsmcure(smcure.fit.500)


set.seed(5092025)
smcure.fit.1000 = smcure(Surv(failtime,rfscens) ~ trt + age + sex,
                        cureform=~trt+age+sex,data=data.E1690.RFS, model="ph",
                        Var = T, nboot = 1000)
printsmcure(smcure.fit.1000)


set.seed(5092025)
smcure.fit.2000 = smcure(Surv(failtime,rfscens) ~ trt + age + sex,
                         cureform=~trt+age+sex,data=data.E1690.RFS, model="ph",
                         Var = T, nboot = 2000)
printsmcure(smcure.fit.2000)


set.seed(5092025)
smcure.fit.5000 = smcure(Surv(failtime,rfscens) ~ trt + age + sex,
                         cureform=~trt+age+sex,data=data.E1690.RFS, model="ph",
                         Var = T, nboot = 5000)
printsmcure(smcure.fit.5000)

source("MCMC_functions.R")
source("SMCM_MCMC.R")
source("SMCFM_MCMC.R")
source("real_data_functions.R")

library(doParallel)
library(parallel)
# getDoParWorkers()

nworkers   <- 2 # number of cores to use
cl         <- makeCluster(nworkers)
clusterCall(cl, function() library(coda)) #for MCMC
clusterCall(cl, function() library(parallel) )
clusterCall(cl, function() library(doParallel) )
clusterCall(cl, function() source("MCMC_functions.R") )
clusterCall(cl, function() source("SMCM_MCMC.R") )
clusterCall(cl, function() source("SMCFM_MCMC.R") )
clusterCall(cl, function() library(rstan))
clusterCall(cl, function() rstan_options(auto_write = TRUE) )
clusterCall(cl, function() stan_model( file = "SMCM.stan" ) )
clusterCall(cl, function() stan_model( file = "HSMCM.stan" ) )
clusterCall(cl, function() stan_model( file = "SMCFM.stan" ) )
clusterCall(cl, function() stan_model( file = "HSMCFM.stan" ) )


registerDoParallel(cl)
# on.exit(stopCluster(cl)) 

Bayesian_criteria              <- c("lpml", "LL", "AIC", "BIC", "k", "p_D", "DIC")

nchains = 2; nIter   = 12500;   warmup = 2500; thin = 20
# nchains = 2; nIter   = 15000;  warmup = 2500; thin = 25  # as in simulation
# nchains = 3; nIter   = 25000;  warmup = 5000; thin = 20
# nchains = 3; nIter   = 60000;   warmup = 10000; thin = 50
# nchains = 4; nIter   = 30000;  warmup = 5000; thin = 50
# nchains = 5; nIter   = 30000;   warmup = 5000; thin = 50


priorPar = list( r1 = 1, delta1 = 0.0001, r2=1, delta2 = 0.0001 )

###### J = 1 ######
out.smcm.mcmc.J1  = Bayes.nonparametric.real.data( model = "SMCM.MCMC", data = real.data.RFS, hyperpar = priorPar, nchains, nIter, warmup, thin, 
                                                    mcmc.parallel = "parLapply", standardize = FALSE, probs = 0, save_loglik = 1, seed = 2025 )
round(out.smcm.mcmc.J1$fit.results,5)
out.smcm.mcmc.J1$Rhat
matrix( out.smcm.mcmc.J1$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

out.smcfm.mcmc.J1 = Bayes.nonparametric.real.data( model = "SMCFM.MCMC", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                   mcmc.parallel = "parLapply", standardize = FALSE, probs = 0, save_loglik = 1, seed =  165251 )
round(out.smcfm.mcmc.J1$fit.results,5)
out.smcfm.mcmc.J1$Rhat
matrix( out.smcfm.mcmc.J1$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

######## rstan model #########
out.hsmcm.rstan.J1   = Bayes.nonparametric.real.data( model = "HSMCM.Rstan", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                      mcmc.parallel = "parLapply", standardize = FALSE, probs = 0, save_loglik = 1, seed =  165251 )
round(out.hsmcm.rstan.J1$fit.results,5)
out.hsmcm.rstan.J1$Rhat[1:10]
matrix( out.hsmcm.rstan.J1$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

out.hsmcfm.rstan.J1   = Bayes.nonparametric.real.data( model = "HSMCFM.Rstan", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                       mcmc.parallel = "parLapply", standardize = FALSE, probs = 0, save_loglik = 1, seed =  165251 )
round(out.hsmcfm.rstan.J1$fit.results,5)
out.hsmcfm.rstan.J1$Rhat[c(1:10, length(out.hsmcfm.rstan.J1$Rhat))]
matrix( out.hsmcfm.rstan.J1$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

 

###### J = 2 ######
out.smcm.mcmc.J2   = Bayes.nonparametric.real.data( model = "SMCM.MCMC", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                    mcmc.parallel = "parLapply", standardize = FALSE, probs = 0.5, save_loglik = 1, seed =  165252 )
round(out.smcm.mcmc.J2$fit.results,5)
out.smcm.mcmc.J2$Rhat
matrix( out.smcm.mcmc.J2$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

out.smcfm.mcmc.J2   = Bayes.nonparametric.real.data( model = "SMCFM.MCMC", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                     mcmc.parallel = "parLapply", standardize = FALSE, probs = 0.5, save_loglik = 1, seed = 165252  )
round(out.smcfm.mcmc.J2$fit.results,5)
out.smcfm.mcmc.J2$Rhat
matrix( out.smcfm.mcmc.J2$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

######## rstan model #########
out.hsmcm.rstan.J2   = Bayes.nonparametric.real.data( model = "HSMCM.Rstan", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                      mcmc.parallel = "parLapply", standardize = FALSE, probs = 0.5, save_loglik = 1, seed = 165252 )
round(out.hsmcm.rstan.J2$fit.results,5)
out.hsmcm.rstan.J2$Rhat[c(1:10,length(out.hsmcm.rstan.J2$Rhat))]
matrix( out.smcm.rstan.J2$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )


out.hsmcfm.rstan.J2   = Bayes.nonparametric.real.data( model = "HSMCFM.Rstan", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                       mcmc.parallel = "parLapply", standardize = FALSE, probs = 0.5, save_loglik = 1, seed = 165252 )
round(out.hsmcfm.rstan.J2$fit.results,5)
out.hsmcfm.rstan.J2$Rhat[1:10]
matrix( out.hsmcfm.rstan.J2$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )


###### J = 3 ######
out.smcm.mcmc.J3  = Bayes.nonparametric.real.data( model = "SMCM.MCMC", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                    mcmc.parallel = "parLapply", standardize = FALSE, probs = c(0.35, 0.70), save_loglik = 1, seed = 165253 )
round(out.smcm.mcmc.J3$fit.results,5)
out.smcm.mcmc.J3$Rhat
matrix( out.smcm.mcmc.J3$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

out.smcfm.mcmc.J3   = Bayes.nonparametric.real.data( model = "SMCFM.MCMC", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                     mcmc.parallel = "parLapply", standardize = FALSE, probs = c(0.35, 0.70), save_loglik = 1, seed = 165253 )
round(out.smcfm.mcmc.J3$fit.results,5)
out.smcfm.mcmc.J3$Rhat
matrix( out.smcfm.mcmc.J3$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

######## rstan model #########
out.hsmcm.rstan.J3   = Bayes.nonparametric.real.data( model = "HSMCM.Rstan", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                      mcmc.parallel = "parLapply", standardize = FALSE, probs = c(0.35, 0.70), save_loglik = 1, seed = 165253)
round(out.hsmcm.rstan.J3$fit.results,5)
out.hsmcm.rstan.J3$Rhat[c(1:10,length(out.hsmcm.rstan.J3$Rhat))]
matrix( out.hsmcm.rstan.J3$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )    

out.hsmcfm.rstan.J3   = Bayes.nonparametric.real.data( model = "HSMCFM.Rstan", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                       mcmc.parallel = "parLapply", standardize = FALSE, probs = c(0.35, 0.70), save_loglik = 1, seed = 165253 )
round(out.hsmcfm.rstan.J3$fit.results,5)
out.hsmcfm.rstan.J3$Rhat[1:10]
matrix( out.hsmcfm.rstan.J3$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )


###### J = 4 ######
out.smcm.mcmc.J4 = Bayes.nonparametric.real.data( model = "SMCM.MCMC", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                    mcmc.parallel = "parLapply", standardize = FALSE, probs = c(0.25, 0.55, 0.75), save_loglik = 1, seed = 165254 )
round(out.smcm.mcmc.J4$fit.results,5)
out.smcm.mcmc.J4$Rhat
matrix( out.smcm.mcmc.J4$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )


out.smcfm.mcmc.J4   = Bayes.nonparametric.real.data( model = "SMCFM.MCMC", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                     mcmc.parallel = "parLapply", standardize = FALSE, probs = c(0.25, 0.50, 0.75), save_loglik = 1, seed = 165254 )
round(out.smcfm.mcmc.J4$fit.results,5)
out.smcfm.mcmc.J4$Rhat
matrix( out.smcfm.mcmc.J4$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

######## rstan model #########
out.hsmcm.rstan.J4 = Bayes.nonparametric.real.data( model = "HSMCM.Rstan", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                    mcmc.parallel = "parLapply", standardize = FALSE, probs = c(0.25, 0.50, 0.75), save_loglik = 1, seed = 165254 ) 
round(out.hsmcm.rstan.J4$fit.results,5)
out.hsmcm.rstan.J4$Rhat[c(1:17, length(out.hsmcm.rstan.J4$Rhat))]
matrix( out.hsmcm.rstan.J4$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )  


out.hsmcfm.rstan.J4   = Bayes.nonparametric.real.data( model = "HSMCFM.Rstan", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                       mcmc.parallel = "parLapply", standardize = FALSE, probs =  c(0.25, 0.50, 0.75), save_loglik = 1, seed = 165254 )
round(out.hsmcfm.rstan.J4$fit.results,5)
out.hsmcfm.rstan.J4$Rhat[c(1:18, length(out.hsmcfm.rstan.J4$Rhat) )]
matrix( out.hsmcfm.rstan.J4$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )


###### J = 5 ######
out.smcm.mcmc.J5 = Bayes.nonparametric.real.data( model = "SMCM.MCMC", data = real.data.RFS, hyperpar = priorPar, nchains, nIter, warmup, thin, 
                                                    mcmc.parallel = "parLapply", standardize = FALSE, probs = c(0.25, 0.50, 0.75, 0.90), save_loglik = 1, seed = 165255)
round(out.smcm.mcmc.J5$fit.results,5)
out.smcm.mcmc.J5$Rhat
matrix( out.smcm.mcmc.J5$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

out.smcfm.mcmc.J5   = Bayes.nonparametric.real.data( model = "SMCFM.MCMC", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                     mcmc.parallel = "parLapply", standardize = FALSE, probs = c(0.25, 0.50, 0.75, 0.90), save_loglik = 1, seed = 165255)
round(out.smcfm.mcmc.J5$fit.results,5)
out.smcfm.mcmc.J5$Rhat
matrix( out.smcfm.mcmc.J5$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

######## rstan model #########
out.hsmcm.rstan.J5 = Bayes.nonparametric.real.data( model = "HSMCM.Rstan", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                    mcmc.parallel = "parLapply", standardize = FALSE, probs = c(0.25, 0.50, 0.75, 0.90), save_loglik = 1, seed = 165255 )
round(out.hsmcm.rstan.J5$fit.results,5)
out.hsmcm.rstan.J5$Rhat[c(1:20,length(out.hsmcm.rstan.J5$Rhat))]
matrix( out.hsmcm.rstan.J5$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )  

out.hsmcfm.rstan.J5   = Bayes.nonparametric.real.data( model = "HSMCFM.Rstan", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                       mcmc.parallel = "parLapply", standardize = FALSE, probs =  c(0.25, 0.50, 0.75, 0.90), save_loglik = 1, seed = 165255 )
round(out.hsmcfm.rstan.J5$fit.results,5)
out.hsmcfm.rstan.J5$Rhat[c(1:20, length(out.hsmcm.rstan.J5$Rhat))]
matrix( out.hsmcfm.rstan.J5$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )


###### J = 7 ######
out.smcm.mcmc.J7   = Bayes.nonparametric.real.data( model = "SMCM.MCMC", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                    mcmc.parallel = "parLapply", standardize = FALSE, probs = c(0.15, 0.30, 0.45, 0.60, 0.75, 0.90), save_loglik = 1, seed = 165257 )
round(out.smcm.mcmc.J7$fit.results,5)
out.smcm.mcmc.J7$Rhat
matrix( out.smcm.mcmc.J7$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

out.smcfm.mcmc.J7   = Bayes.nonparametric.real.data( model = "SMCFM.MCMC", data = real.data.RFS, nchains, nIter, warmup, thin, 
                                                     mcmc.parallel = "parLapply", standardize = FALSE, probs = c(0.15, 0.30, 0.45, 0.60, 0.75, 0.90), save_loglik = 1, seed = 165257)
round(out.smcfm.mcmc.J7$fit.results,5)
out.smcfm.mcmc.J7$Rhat
matrix( out.smcfm.mcmc.J7$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

######## rstan model #########
out.hsmcm.rstan.J7 = Bayes.nonparametric.real.data( model = "HSMCM.Rstan", data = real.data.RFS, hyperpar = priorPar, nchains, nIter, warmup, thin, 
                                                    mcmc.parallel = "parLapply", standardize = FALSE, probs = c(0.15, 0.30, 0.45, 0.60, 0.75, 0.90), save_loglik = 1, seed = 165257 )
round(out.hsmcm.rstan.J7$fit.results,5)
out.hsmcm.rstan.J7$Rhat[c(1:14,length(out.hsmcm.rstan.J7$Rhat))]
matrix( out.hsmcm.rstan.J7$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )  


out.hsmcfm.rstan.J7 = Bayes.nonparametric.real.data( model = "HSMCFM.Rstan", data = real.data.RFS, hyperpar = priorPar, nchains, nIter, warmup, thin, 
                                                    mcmc.parallel = "parLapply", standardize = FALSE, probs = c(0.15, 0.30, 0.45, 0.60, 0.75, 0.90), save_loglik = 1, seed = 165257 )
round(out.hsmcfm.rstan.J7$fit.results,5)
out.hsmcfm.rstan.J7$Rhat[c(1:17,length(out.hsmcfm.rstan.J7$Rhat))]
matrix( out.hsmcfm.rstan.J7$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )  

###### J = 10 ######
out.smcm.mcmc.J10   = Bayes.nonparametric.real.data( model = "SMCM.MCMC", data = real.data.RFS, hyperpar = priorPar, nchains, nIter, warmup, thin, 
                                                    mcmc.parallel = "parLapply", standardize = FALSE, probs = get_probs(10), save_loglik = 1, seed = 1652510 )
round(out.smcm.mcmc.J10$fit.results,5)
out.smcm.mcmc.J10$Rhat
matrix( out.smcm.mcmc.J10$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

out.smcfm.mcmc.J10   = Bayes.nonparametric.real.data( model = "SMCFM.MCMC", data = real.data.RFS, hyperpar = priorPar, nchains, nIter, warmup, thin, 
                                                     mcmc.parallel = "parLapply", standardize = FALSE, probs = get_probs(10), save_loglik = 1, seed = 1652510)
round(out.smcfm.mcmc.J10$fit.results,5)
out.smcfm.mcmc.J10$Rhat
matrix( out.smcfm.mcmc.J10$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

######## rstan model #########
out.hsmcm.rstan.J10 = Bayes.nonparametric.real.data( model = "HSMCM.Rstan", data = real.data.RFS, hyperpar = priorPar, nchains, nIter, warmup, thin, 
                                                    mcmc.parallel = "parLapply", standardize = FALSE, probs = get_probs(10), save_loglik = 1, seed = 1652510 )
round(out.hsmcm.rstan.J10$fit.results,5)
out.hsmcm.rstan.J10$Rhat[c(1:17,length(out.hsmcm.rstan.J10$Rhat))]
matrix( out.hsmcm.rstan.J10$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )  

out.hsmcfm.rstan.J10 = Bayes.nonparametric.real.data( model = "HSMCFM.Rstan", data = real.data.RFS, hyperpar = priorPar, nchains, nIter, warmup, thin, 
                                                     mcmc.parallel = "parLapply", standardize = FALSE, probs = get_probs(10), save_loglik = 1, seed = 1652510 )
round(out.hsmcfm.rstan.J10$fit.results,5)
out.hsmcfm.rstan.J10$Rhat[c(1:17,length(out.hsmcfm.rstan.J10$Rhat))]
matrix( out.hsmcfm.rstan.J10$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )  

###### SD, Interval and plots ###### 
out = out.smcm.mcmc.J1 #out.smcfm.mcmc.J3
out$mcmc.info
thin = out$mcmc.info$thin
warmup = out$mcmc.info$warmup
SD.posterior(out,    stan.model = F, frailty = F) # for smcm.mcmc
# SD.posterior(out,  stan.model = F, frailty = T) # for smcfm.mcmc

out = out.hsmcm.rstan.J1 
SD.posterior(out, stan.model = T, frailty = F) # for hsmcm.rstan
# SD.posterior(out, stan.model = T, frailty = T) # for hsmcfm.rstan
library(bayesplot)
mcmc_trace(out$fit, pars=c("b[1]","b[2]","b[3]","b[4]") )
mcmc_trace(out$fit, pars=c("beta[1]","beta[2]","beta[3]") )

HPD.credible.interval(fit.mcmc.chains=out$fit, pars="b.p",     warmup, thin )
HPD.credible.interval(fit.mcmc.chains=out$fit, pars="beta.p",   warmup, thin )
HPD.credible.interval(fit.mcmc.chains=out$fit, pars="lambda.p", warmup, thin)
HPD.credible.interval(fit.mcmc.chains=out$fit, pars="theta.p",  warmup, thin)

round(HPD.credible.interval.stan.fit(out, pars = "b.p"),4)
round(HPD.credible.interval.stan.fit(out, pars = "beta.p"),4)
round(HPD.credible.interval.stan.fit(out, pars = "lambda.p"),4)
round(HPD.credible.interval.stan.fit(out, pars = "theta.p"),4)

mcmc_trace_mcmc.smc(fit.mcmc.chains=out$fit, pars="b.p", warmup, thin )
mcmc_trace_mcmc.smc(fit.mcmc.chains=out$fit, pars="beta.p", warmup, thin )
mcmc_trace_mcmc.smc(fit.mcmc.chains=out$fit, pars="lambda.p", warmup, thin )
mcmc_trace_mcmc.smc(fit.mcmc.chains=out$fit, pars="theta.p", warmup, thin )







####### end of E1690 analysis as Yin and Ibrahim (2005)  #######


####### E1690 data analysis as Castro and Gomez (2020) using the survival time with its censoring indicator, trt, age and sex variables  #######
#### from https://github.com/psioda/bayes-design-hist-cure-rate/blob/master/data/raw_data/mina-readme.txt
# data <- read.table("/Users/fatihki/UiO/SemiParMixtureCure/mina-e1684-e1690.txt", header = TRUE)
data <- read.table("mina-e1684-e1690.txt", header = TRUE)
table(data$study)
colnames(data)


data.E1690         <- data[data$study == "1690", ]
data.E1690$nodes   <- as.numeric(data.E1690$nodes)
# data.E1690$nodes   <- as.factor(data.E1690$nodes)
data.E1690$breslow <- as.numeric(data.E1690$breslow) # 10 NA !!!  # if you use this variable, apply na.omit before that!!!
data.E1690         <- na.omit(data.E1690)
# data.E1690$stage   <- as.factor(data.E1690$stage) # "-2" level should be removed before the use!
dim(data.E1690)


table(data.E1690$scens)/length(data.E1690$scens)
summary(data.E1690$survtime)
summary(data.E1690$breslow); sd(data.E1690$breslow)
table(data.E1690$perform)
table(data.E1690$sex)
table(data.E1690$nodes)

#### As in Model 1 in the example of Castro, Cancho and Rodrigues (2009) study #####
# real data based on the overall survival time
real.data.full.OS = list()
# real.data.full.OS$X = as.matrix( cbind( trt=data.E1690$trt, age=data.E1690$age,
#                                    nodes=data.E1690$nodes, sex=data.E1690$sex,
#                                    ps=data.E1690$perform,  breslow=data.E1690$breslow
                                    # ) )
real.data.full.OS$X = model.matrix(~ data.E1690$trt + data.E1690$age + data.E1690$sex +(data.E1690$nodes)) 
head(real.data.full.OS$X)
# head(scale.dummy.matrix(real.data.full.OS$X))
real.data.full.OS$Z =  cbind(1, real.data.full.OS$X)  
head(real.data.full.OS$Z)

real.data.full.OS$observed_time = data.E1690$survtime
real.data.full.OS$delta         = data.E1690$scens

Bayesian_criteria              <- c("lpml", "LL", "AIC", "BIC", "k", "p_D", "DIC")
nchains = 2; nIter   = 6000;   warmup = 1000; thin = 20
# nchains = 2; nIter   = 30000;  warmup = 10000; thin = 50  # as in simulation
priorPar = list( r1 = 1, delta1 = 1e-03, r2=1, delta2 = 1e-03 )
###### J = 1 ######
out.smcm.mcmc.J1   = Bayes.nonparametric.real.data( model = "SMCM.MCMC", data = real.data.full.OS, hyperpar = priorPar, nchains, nIter, warmup, thin, 
                                                    mcmc.parallel = "parLapply", standardize = FALSE, probs = 0, save_loglik = 1, seed = 165251 )
round(out.smcm.mcmc.J1$fit.results,5)
out.smcm.mcmc.J1$Rhat
matrix( out.smcm.mcmc.J1$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

######## rstan model #########
out.hsmcm.rstan.J1   = Bayes.nonparametric.real.data( model = "HSMCM.Rstan", data = real.data.full.OS, hyperpar = priorPar, nchains, nIter, warmup, thin, 
                                                      mcmc.parallel = "parLapply", standardize = FALSE, probs = 0, save_loglik = 1 )
round(out.hsmcm.rstan.J1$fit.results,5)
out.hsmcm.rstan.J1$Rhat[1:10]
matrix( out.hsmcm.rstan.J1$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

###### J = 2 ######
######## rstan model #########
out.hsmcm.rstan.J2   = Bayes.nonparametric.real.data( model = "HSMCM.Rstan", data = real.data.full.OS, hyperpar = priorPar, nchains, nIter, warmup, thin, 
                                                      mcmc.parallel = "parLapply", standardize = FALSE, probs = 0.5, save_loglik = 1, seed = 165252 )
round(out.hsmcm.rstan.J2$fit.results,5)
out.hsmcm.rstan.J2$Rhat[c(1:10,length(out.hsmcm.rstan.J2$Rhat))]
matrix( out.hsmcm.rstan.J2$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )


out.hsmcfm.rstan.J2   = Bayes.nonparametric.real.data( model = "HSMCFM.Rstan", data = real.data.full.OS, hyperpar = priorPar, nchains, nIter, warmup, thin, 
                                                       mcmc.parallel = "parLapply", standardize = FALSE, probs = 0.5, save_loglik = 1, seed = 165252 )
round(out.hsmcfm.rstan.J2$fit.results,5)
out.hsmcfm.rstan.J2$Rhat[1:10]
matrix( out.hsmcfm.rstan.J2$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

###### J = 3 ######
######## rstan model #########
out.hsmcm.rstan.J3   = Bayes.nonparametric.real.data( model = "HSMCM.Rstan", data = real.data.full.OS, hyperpar = priorPar, nchains, nIter, warmup, thin, 
                                                      mcmc.parallel = "parLapply", standardize = FALSE, probs = c(0.35, 0.70), save_loglik = 1, seed = 165253)
round(out.hsmcm.rstan.J3$fit.results,5)
out.hsmcm.rstan.J3$Rhat[c(1:10,length(out.hsmcm.rstan.J3$Rhat))]
matrix( out.hsmcm.rstan.J3$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )   

out.hsmcfm.rstan.J3   = Bayes.nonparametric.real.data( model = "HSMCFM.Rstan", data = real.data.full.OS, hyperpar = priorPar, nchains, nIter, warmup, thin, 
                                                       mcmc.parallel = "parLapply", standardize = FALSE, probs = c(0.35, 0.70), save_loglik = 1, seed = 165253 )
round(out.hsmcfm.rstan.J3$fit.results,5)
out.hsmcfm.rstan.J3$Rhat[1:10]
matrix( out.hsmcfm.rstan.J3$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

###### J = 4 ######
out.hsmcfm.rstan.J4   = Bayes.nonparametric.real.data( model = "HSMCFM.Rstan", data = real.data.full.OS, hyperpar = priorPar, nchains, nIter, warmup, thin, 
                                                       mcmc.parallel = "parLapply", standardize = FALSE, probs =  c(0.25, 0.50, 0.75), save_loglik = 1, seed = 165254 )
round(out.hsmcfm.rstan.J4$fit.results,5)
out.hsmcfm.rstan.J4$Rhat[c(1:18, length(out.hsmcfm.rstan.J4$Rhat) )]
matrix( out.hsmcfm.rstan.J4$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

###### J = 5 ######
######## rstan model #########
out.hsmcm.rstan.J5 = Bayes.nonparametric.real.data( model = "HSMCM.Rstan", data = real.data.full.OS, hyperpar = priorPar, nchains, nIter, warmup, thin, 
                                                    mcmc.parallel = "parLapply", standardize = FALSE, probs = c(0.25, 0.50, 0.75, 0.90), save_loglik = 1, seed = 165255 )
round(out.hsmcm.rstan.J5$fit.results,5)
out.hsmcm.rstan.J5$Rhat[c(1:20,length(out.hsmcm.rstan.J5$Rhat))]
matrix( out.hsmcm.rstan.J5$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )  

out.hsmcfm.rstan.J5   = Bayes.nonparametric.real.data( model = "HSMCFM.Rstan", data = real.data.full.OS, hyperpar = priorPar, nchains, nIter, warmup, thin, 
                                                       mcmc.parallel = "parLapply", standardize = FALSE, probs =  c(0.25, 0.50, 0.75, 0.90), save_loglik = 1, seed = 165255 )
round(out.hsmcfm.rstan.J5$fit.results,5)
out.hsmcfm.rstan.J5$Rhat[c(1:20, length(out.hsmcm.rstan.J5$Rhat))]
matrix( out.hsmcfm.rstan.J5$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
        byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )

####### Other packages for E1684 and E1690 data sets #######
# full data sets are available hdbayes package
# library(hdbayes)
# E1684 = E1684
# E1690 = E1690
# E1694 = E1694
# E2696 = E2696
# 
# table(E1690$failcens)
# table(E1690$survcens)
# summary(E1690$age)
# summary(E1684$age)
# summary(e1684$AGE-mean(e1684$AGE))
# 
# summary(E1690$survtime)
# summary(E1690$failtime)
# sort(E1690$failtime)
# sort(E1690$survtime)
# summary(e1684$FAILTIME)
# 
# ######## E1690 analysis 
# library(survival)
# library(survminer)
# library(ggplot2)
# 
# fit.E1690.0 <- survfit(Surv(failtime, failcens) ~ 1, data = E1690)
# ggsurvplot(fit.E1690.0, conf.int = F, legend = "none", xlab = "Time (year)",)
# 
# fit.E1690.1 <- survfit(Surv(failtime, failcens) ~ treatment, data = E1690)
# ggsurvplot(fit.E1690.1)
# 
# 
# cox.fit.E1690 <- coxph( Surv(failtime, failcens) ~  treatment + sex + age, data = E1690)
# summary(cox.fit.E1690)
# 
# 
# library(smcure)
# smcure.E1690 <- smcure( Surv(failtime, failcens) ~ treatment + sex + age, cureform = ~treatment + sex + age, data = E1690, 
#                        model="ph", Var = TRUE )
# printsmcure(smcure.E1690, Var = T)
# 
# 
# 
# 
# nIter   = 25000;  nchains = 3; warmup = 5000; thin = 10
# nchains = 3; nIter = 5000; warmup = 1000; thin = 10;
# 
# library(dplyr)
# # data = E1690
# data.fail = E1690 %>% filter(failtime != 0)
# table(data.fail$failcens)
# table(data.fail$node_bin)
# summary(data.fail$failtime)
# summary(data.fail$survtime)
# 
# summary(E1690$survtime)
# 
# cov.E1690 = data.fail[, c("treatment", "sex", "node_bin", "age")]
# head(cov.E1690)
# 
# real.data = list()
# real.data$X = cov.E1690
# real.data$Z = cbind(1, cov.E1690) 
# real.data$observed_time = data.fail$failtime #E1690$survtime #
# real.data$delta = data.fail$failcens # E1690$survcens #
# 
# df.e1690.fail = data.frame(real.data)
# 
# probs     <- c(0.5, 0.9)
# 
# 
# library(doParallel)
# library(parallel)
# getDoParWorkers()
# 
# nworkers   <- nchains # number of cores to use
# cl         <- makeCluster(nworkers)
# clusterCall(cl, function() library(coda)) #for MCMC
# clusterCall(cl, function() library(parallel) )
# clusterCall(cl, function() library(doParallel) )
# clusterCall(cl, function() source("MCMC_functions.R") )
# clusterCall(cl, function() source("SMCM_MCMC.R") )
# clusterCall(cl, function() source("SMCFM_MCMC.R") )
# 
# # on.exit(stopCluster(cl)) 
#  
# Bayesian_criteria              <- c("lpml", "LL", "AIC", "BIC", "k", "p_D", "DIC")
# 
# # probs = c(0.25, 0.50, 0.75, 0.90) #0 # 0.5 # c(0.35, 0.7) #c(0.3, 0.6, 0.90) # 
# # debug(Bayes.nonparametric.real.data)
# out.smcm.mcmc.J1   = Bayes.nonparametric.real.data( model = "SMCM.MCMC", data = real.data, nchains, nIter, warmup, thin, 
#                                                  mcmc.parallel = "parLapply", standardize = FALSE, probs = 0, save_loglik = 1 )
# 
# out.smcm.mcmc.J2   = Bayes.nonparametric.real.data( model = "SMCM.MCMC", data = real.data, nchains, nIter/2, warmup/2, thin, 
#                                                  mcmc.parallel = "parLapply", standardize = FALSE, probs = 0.5, save_loglik = 1 )
# 
# out.smcm.mcmc.J5   = Bayes.nonparametric.real.data( model = "SMCM.MCMC", data = real.data, nchains, nIter/2, warmup/2, thin, 
#                                                     mcmc.parallel = "parLapply", standardize = FALSE, probs = c(0.25, 0.50, 0.75, 0.90), save_loglik = 1 )
# 
# out.smcm.mcmc.J5$fit.results
# round(out.smcm.mcmc.J2$fit.results, 4)
# out.smcm.mcmc.J5$Rhat
# matrix( out.smcm.mcmc.J5$loo.results[ Bayesian_criteria ], ncol= length(Bayesian_criteria), 
#         byrow=T, dimnames = list( NULL, Bayesian_criteria  ) )
# mcmc_trace_mcmc.smc(fit.mcmc.chains=out.smcm.mcmc.J5$fit, pars="b.p", warmup, thin )
# mcmc_trace_mcmc.smc(fit.mcmc.chains=out.smcm.mcmc.J5$fit, pars="beta.p", warmup, thin )
# mcmc_trace_mcmc.smc(fit.mcmc.chains=out.smcm.mcmc.J5$fit, pars="lambda.p", warmup, thin )
# 
# 
# HPD.credible.interval(fit.mcmc.chains=out.smcm.mcmc$fit, pars="b.p",     warmup, thin )
# HPD.credible.interval(fit.mcmc.chains=out.smcm.mcmc$fit, pars="beta.p",     warmup, thin )
# HPD.credible.interval(fit.mcmc.chains=out.smcm.mcmc$fit, pars="lambda.p",     warmup, thin)
# 
# out.smcfm.mcmc  = Bayes.nonparametric.real.data( model = "SMCFM.MCMC", data = real.data, nchains, nIter, warmup, thin, 
#                                                  mcmc.parallel = "parLapply", standardize = FALSE, probs = probs, save_loglik = 1  )

# hdcuremodels R package from Han Fu 
#  library(hdcuremodels)
#  # undebug(cureem)
#  data.cure = data.frame(Time = real.data$observed_time, Censor = real.data$delta, X = real.data$X)
#  fit <- cureem(Surv(real.data$observed_time, real.data$delta) ~ as.matrix(real.data$Z), data = data.cure, x.latency = as.matrix(real.data$X),
#                model = "cox", penalty = "lasso",
#                lambda.inc = 0.1, lambda.lat = 0.1, gamma.inc = 6, gamma.lat = 10)
#  fit$b0_path
#  fit$b_path
#  fit$beta_path
#  
#  
#  fit.cv <- cv_cureem(Surv(real.data$observed_time, real.data$delta) ~ as.matrix(real.data$Z), data = data.cure, 
#                      x.latency = as.matrix(real.data$X),
#                      model = "cox", penalty = "lasso",
#                      grid.tuning = FALSE, nlambda.inc = 10, nlambda.lat = 10,
#                      n_folds = 5, seed = 123, verbose = TRUE)
#  
# c(b0=fit.cv$b0, b=fit.cv$b, beta=fit.cv$beta)
 
 