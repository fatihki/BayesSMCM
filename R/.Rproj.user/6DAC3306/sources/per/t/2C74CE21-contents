#' HPD.interval.mcmc 
#'
#' @title Highest Posterior Density (HPD) intervals for all MCMC chains of SMCM and SMCFM.
#' 
#' @description
#' It is calculated by using coda::\link[coda]{HPDinterval}.
#' 
#' @import coda
#' 
#' @name HPD.interval.mcmc 
#' @param fit.mcmc.chains MCMC results for all the chains based on our MCMC results.
#' @param pars Parameters can be "beta.p" or "b.p" or "lambda.p".
#' @param warmup The number of warmup iterations included in fit.mcmc.chains, as the same as "burn-in".
#' @param thin The number of thinning.
#' @param ... If you have true values of the parameters, give it as "pars.true", then cp value return as 0 and 1 for each parameter wrt hpd interval includes true value or not.
#' @return A data frame containing the lower and upper bounds of the 95% HPD credible interval for each parameter. If true parameter values are provided, an additional column 'cp' indicates whether the true value falls within the interval (1) or not (0).
#' @examples
#' # Assuming fit.mcmc.chains is a list of MCMC results from multiple chains
#' # hpd_intervals <- HPD.interval.mcmc(fit.mcmc.chains, pars = "beta.p", warmup = 1000, thin = 10)
#' @export
HPD.interval.mcmc <- function(fit.mcmc.chains, pars, warmup, thin, ...  ){

  nchains                       <- length(fit.mcmc.chains)
  n_row                         <- nrow(fit.mcmc.chains[[1]][[pars]])
  n_col                         <- ncol(fit.mcmc.chains[[1]][[pars]])
  args                          <- list(...)
  pars.true                     <- if ("pars.true" %in% names(args)) args$pars.true else NA
  
  mcmc.chains                   <- array( unlist( lapply(fit.mcmc.chains, function(x) x[[pars]] ) ),  dim = c( n_row, n_col, nchains ) )
  
  dimnames(mcmc.chains)[[1]]    <- 1:n_row
  if(pars == "b.p"){
    dimnames(mcmc.chains)[[2]]  <- paste0(pars,"[", 0:(n_col-1),"]")
  }else{
    dimnames(mcmc.chains)[[2]]  <- paste0(pars,"[", 1:(n_col),"]")
  }
  dimnames(mcmc.chains)[[3]]    <- paste0("chain", 1:nchains) 
  
  mcmc.chains.list              <- coda::mcmc.list(
    lapply(1:nchains, function(chain) { 
      df           <- as.data.frame(mcmc.chains[ , , chain])
      colnames(df) <- dimnames(mcmc.chains)[[2]]
      coda::mcmc(df)
      # mcmc(as.data.frame( mcmc.chains[ , , chain ], col.names = dimnames(mcmc.chains)[[2]] ) )
    } ) )
  
  mcmc.chains.list.R1           <- window(mcmc.chains.list, start = warmup + 2, thin = thin)
  combined.mcmc.chains          <- do.call(rbind, mcmc.chains.list.R1) 
  
  hpd.interval                  <- coda::HPDinterval( coda::as.mcmc(combined.mcmc.chains), prob = 0.95 )
  hpd.interval                  <- as.data.frame(hpd.interval)           
  
  if( !is.na(pars.true[1]) ){
    for (i in 1:n_col) {
      hpd.interval[i, "cp"]     <- ifelse( (hpd.interval$lower[i]<= pars.true[i] & pars.true[i] <= hpd.interval$upper[i] ), 1, 0) } 
  }else{
    hpd.interval = hpd.interval
  }
  
  return(hpd.interval)
}